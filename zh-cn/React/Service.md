## 测试环境问题排查的那些事儿

**排查实践**

**案例一** **问题：**测试环境一个查询商品列表的接口，响应非常慢，经常超时。

**总结：**这个案例充分展示了合理使用工具的重要性。通过服务管理平台，能够快速确认服务是正常的，问题在于部分接口；通过 zzapm 强大的调用链追踪能力，能准确定位到耗时的节点，确定问题原因。

**案例二 问题：某 RPC 服务，部署后启动失败。**

**排查过程：**

- Step 1：查看服务进程，发现进程不存在；查看服务日志，发现没有生成日志；
- Step 2：查看 Java 虚拟机日志，发现在日志中间有一条异常输出，表明服务的端口被占用了；

**总结：**端口冲突的问题，曾经在测试环境频繁出现，给我们制造了很多麻烦。通过在排查过程中不断分析和总结，我们确定了问题的根本原因在于端口使用的不规范。进而制定并推广了服务端口的分配规范，只允许使用指定范围内的监听端口，并在测试环境中对这些端口进行了预留，从而彻底解决了这一问题。

## 大文件切片上传+断点续传

1. 文件格式校验

2. 文件切片、md5 计算

3. 发起检查请求，把当前文件的 hash 发送给服务端，检查是否有相同 hash 的文件

4. 上传进度计算

5. 上传完成后通知后端合并切片

## 支付流程

商品金额发改后端，后端对比之后加密返回给我订单信息

我收到加密后的信息，发给支付宝，该怎么支付怎么支付

支付完成之后，支付宝会给移动端和客后端分别发送支付信息

然后前端把收到的信息发给后端进行对比

后端对比成功，更改自己订单状态

## 扫码登录

1、前端点击生成二维码按钮或点击相关链接

2、该网页生成唯一个 id 的二维码，关闭该页面或每次刷新后都会改变。

3、浏览器把这个 id 通知给服务器，告诉服务器有这个二维码

4、服务器知道了这个 id,和浏览器建立长轮询，等待有人扫这个二维码

5、有人扫了这个二维码，浏览器(通过长轮询）查询到这个 id 的扫描记录（并得到 201 返回码），立刻通知服务器有人扫了

6、手机扫描后进入了新的页面，同时也可以在手机上直接和服务器进行资源交换了
在第 5 步，如果一直没人扫，长轮询检测不到有人扫描，会接到状态码 408（请求超时），页面可以设计成提醒”二维码已过期请刷新”

## 单点登录（SSO）解决方案介绍

单点登录基本流程如下：

1）当用户第一次访问应用系统的时候，因为还没有登录，会被引导到认证系统中进行登录；

2）根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket；

3）用户再访问别的应用的时候，就会将这个 ticket 带上，作为自己认证的凭据，应用系统接受到请求之后会把 ticket 送到认证系统进行校验，检查 ticket 的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统 2 和应用系统 3 了。

**同域下的单点登录**
一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com 和 app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。

我们只要在 sso.a.com 登录，app1.a.com 和 app2.a.com 就也登录了。通过上面的登陆认证机制，我们可以知道，在 sso.a.com 中登录了，其实是在 sso.a.com 的服务端的 session 中记录了登录状态，同时在浏览器端（Browser）的 sso.a.com 下写入了 Cookie。那么我们怎么才能让 app1.a.com 和 app2.a.com 登录呢？这里有两个问题：

Cookie 是不能跨域的，我们 Cookie 的 domain 属性是 sso.a.com，在给 app1.a.com 和 app2.a.com 发送请求是带不上的。
sso、app1 和 app2 是不同的应用，它们的 session 存在自己的应用内，是不共享的。

**不同域下的单点登录**
用户访问 app 系统，app 系统是需要登录的，但用户现在没有登录。

跳转到 CAS server，即 SSO 登录系统，以后图中的 CAS Server 我们统一叫做 SSO 系统。SSO 系统也没有登录，弹出用户登录页。

用户填写用户名、密码，SSO 系统进行认证后，将登录状态写入 SSO 的 session，浏览器（Browser）中写入 SSO 域下的 Cookie。

SSO 系统登录完成后会生成一个 ST（Service Ticket），然后跳转到 app 系统，同时将 ST 作为参数传递给 app 系统。

app 系统拿到 ST 后，从后台向 SSO 发送请求，验证 ST 是否有效。

验证通过后，app 系统将登录状态写入 session 并设置 app 域下的 Cookie。

## 微前端是什么？

微前端的概念来源于微服务，摒弃了大型单体应用的方式，将前端整体分解为小而简单的块儿，这些块儿可以独立的开发、独立测试、独立部署、同时仍然可以聚合为一个产品来使用。

## 你了了解哪些前端安全相关的知识？

**浏览器器相关:**

- XSS
- CSRF
- HTTPS、
- CSP (内容安全策略略, 可以禁⽌止加载外域代码, 禁⽌止外域提交等等)、
- HSTS (强制客户端使⽤用 HTTPS 与服务端建⽴立连接)、X-Frame-Options (控制当前⻚页⾯面是否可以被嵌⼊入到 Ifrmae 中)、SRI (subresource intergrity ⼦子资源完整性, 前端可以⽤用 webpack-subresource-integrity 插件,
  在每个 script 上添加 hash 值, 校验加载的资源是否和当时打包⽣生成的⼀一致)、
- Referrer-Policy (控制 referer 的携带策略略)

**Node(服务端)相关**

- 本地⽂文件操作相关:路路径拼接导致的⽂文件泄露露
- ReDOS
- 时序攻击
- ip origin referrer 等 request headers 的校验(在做爬⾍虫应⽤用的时候对此会有深刻的体会)

**能稍微详细的聊⼀一下 XSS 吗?**

- Cross-site scripting, 跨站脚本, 通常简称为 XSS.
  > [!TAU]
  > 说⽩白了了就是攻击者想尽⼀一切办法将可执⾏行行代码注⼊入到⽹网⻚页中, ⽽而恶意代码未经过滤，与⽹网站正 常的代码混在⼀一起;浏览器器⽆无法分辨哪些脚本是可信的，导致恶意脚本被执⾏行行。

**外在表现上, 都有哪些攻击场景?**

- 评论区植⼊入 js 代码(即可输⼊入的地⽅方植⼊入 js 代码)
- url 上拼接 js 代码

**有哪些 xss 攻击的类型呢?**

_存储型 Server_
场景:常⻅见于带有⽤用户保存数据的⽹网站功能，攻击者通过可输⼊入区域来注⼊入恶意代码, 如论坛 发帖、商品评论、⽤用户私信等。
攻击步骤:

1. 攻击者将恶意代码提交到⽬目标⽹网站的数据库中

2. ⽤用户打开⽬目标⽹网站时，服务端将恶意代码从数据库中取出来，拼接在 HTML 中返回给浏览器器(因为⽤用户之间是可以相互看到帖⼦子、评论等的)

3. ⽤用户浏览器器在收到响应后解析执⾏行行，混在其中的恶意代码也同时被执⾏行行

4. 恶意代码窃取⽤用户数据并发送到攻击者的⽹网站，或者冒充⽤用户⾏行行为，调⽤用⽬目标⽹网站的接⼝口
   执⾏行行攻击者指定的操作。

_反射型 Server_

与存储型的区别在于，存储型的恶意代码通过可输⼊入区域, 存储在数据库中，⽽而反射型的恶意 代码拼接在 URL 上。

由于需要⽤用户主动打开恶意的 URL 才能⽣生效，攻击者往往会结合多种⼿手段诱导⽤用户点击。

场景:通过 URL 传递参数的功能，如⽹网站搜索、跳转等。

攻击步骤:

1. 攻击者构造出特殊的 URL，其中包含恶意代码。

2. ⽤用户打开带有恶意代码的 URL 时，⽹网站服务端将恶意代码从 URL 中取出，拼接在 HTML
   中返回给浏览器器。

3. ⽤用户浏览器器接收到响应后解析执⾏行行，混在其中的恶意代码也被执⾏行行。

4. 恶意代码窃取⽤用户数据并发送到攻击者的⽹网站，或者冒充⽤用户的⾏行行为，调⽤用⽬目标⽹网站的接
   ⼝口执⾏行行攻击者指定的操作。

_Dom 型 Browser_

DOM 型 XSS 攻击中，取出和执⾏行行恶意代码由浏览器器端完成，属于前端 JavaScript ⾃自身的安全漏漏洞洞，而其他两种 XSS 都属于服务端的安全漏漏洞洞。

场景:通过 URL 传递参数的功能，如⽹网站搜索、跳转等。 攻击步骤:

1. 攻击者构造出特殊的 URL，其中包含恶意代码。

2. ⽤用户打开带有恶意代码的 URL。

3. ⽤用户浏览器器接收到响应后解析执⾏行行，前端 JavaScript 取出 URL 中的恶意代码并执⾏行行。

4. 恶意代码窃取⽤用户数据并发送到攻击者的⽹网站，或者冒充⽤用户的⾏行行为，调⽤用⽬目标⽹网站的接⼝口执⾏行行攻击者指定的操作。

## 如何防范 XSS 攻击呢?

对数据进⾏行行严格的输出编码:如 HTML 元素的编码，JS 编码，CSS 编码，URL 编码等等

1. 避免拼接 HTML;Vue/React 技术栈，避免使⽤用 v-html / dangerouslySetInnerHTML

2.CSP HTTP Header，即 Content-Security-Policy(不不⽀支持 CSP 的旧版浏览器器可以设置 X-XSS- Protection)

增加攻击难度，配置 CSP(本质是建⽴立⽩白名单，由浏览器器进⾏行行拦截)

Content-Security-Policy:
default-src ‘self’ -所有内容均来⾃自站点的同⼀一个源(不不包括其⼦子 域名)

Content-Security-Policy: default-src ‘self’ \*.trusted.com -允许内容来⾃自信任的域名及其 ⼦子域名 (域名不不必须与 CSP 设置所在的域名相同)

Content-Security-Policy: default-src https://lubai.com -该服务器器仅允许通过 HTTPS ⽅方式

3.输⼊入验证:⽐比如⼀一些常⻅见的数字、URL、电话号码、邮箱地址等等做校验判断

4. 开启浏览器器 XSS 防御:Http Only cookie，禁⽌止 JavaScript 读取某些敏敏感 Cookie，攻击者完成 XSS 注⼊入后也⽆无法窃取此 Cookie。

5. 验证码

## 那再来说⼀一下 CSRF 吧?

Cross-site request forgery, 跨站请求伪造

攻击者诱导受害者进入恶意⽹网站，在第三⽅方⽹网站中，向被攻击⽹网站发送跨站请求。利利⽤用受害者
在被攻击⽹网站已经获取的注册凭证，绕过后台的⽤用户验证，达到冒充⽤用户对被攻击的⽹网站执⾏行行
某项操作的⽬目的。

**如何防范 CSRF 的攻击呢?**

阻⽌止第三⽅方域名的访问

1.Cookie SameSite
SameSite 有 3 个值: Strict, Lax 和 None

- Strict:浏览器器会完全禁⽌止第三⽅方 cookie。⽐比如 a.com 的⻚页⾯面中访问 b.com 的资源，那么 a.com 中的 cookie 不不会被发送到 b.com 服务器器，只有从 b.com 的站点去请求 b.com 的资源，才 会带上这些 Cookie

- Lax:在跨站点的情况下，从第三⽅方站点链接打开和从第三⽅方站点提交 Get ⽅方式的表单这两种 ⽅方式都会携带 Cookie。但如果在第三⽅方站点中使⽤用 POST ⽅方法或者通过 img、Iframe 等标签加 载的 URL，这些场景都不不会携带 Cookie
  None:任何情况下都会发送 Cookie 数据

  2.同源检测

通过检测 request header 中的 origin referer 等, 来确定发送请求的站点是否是⾃自⼰己期望中站点.

提交请求时附加额外信息

1.CSRFToken

用户打开页⾯的时候, 服务器器利利⽤用加密算法给当前⽤用户⽣生成⼀一个 ToKen

每次⻚⾯加载时, 前端把获取到的 Token 加到所有的能发请求的 html 元素上, ⽐比如 form, a 每次前端发起请求, 都携带 Token 参数

服务端每次接收请求, 都校验 Token 的有效性.

2.双重 Cookie

⽤用户访问⽹网站的时候, 服务器器向浏览器器注⼊入⼀一个额外的 cookie, 内容随便便, ⽐比如 csrfcookie=lubaixzxfasdfasfew

每次前端发起请求, 都在请求上拼接上 csrfcookie 这个参数, 参数值就从 cookie ⾥里里获取

服务端每次收到请求, 就去校验请求参数⾥里里的值和 cookie ⾥里里的值是否⼀一致

## Node(服务端)相关的安全问题有了了解过吗? ⼤大概举⼏几个例例⼦子?

本地⽂文件操作

⽐如我们提供⼀一个静态服务, 通过请求的参数 url 来返回给⽤用户或者前端想要的资源.

新建⽂文件夹 static,⾥里里⾯面随便便放点⽂文件,提供给外界请求

**怎么解决这个问题?**

很多 node 框架都⾃自带插件来屏蔽这个问题的发⽣生 ⽐比如 express.static, koa-static, 当然也有第三⽅方包⽀支持(resolve-path) 咱们⽤用 resove-path 来解决⼀一下这个问题.
