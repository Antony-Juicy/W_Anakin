## 大文件切片上传+断点续传

1. 文件格式校验

2. 文件切片、md5 计算

3. 发起检查请求，把当前文件的 hash 发送给服务端，检查是否有相同 hash 的文件

4. 上传进度计算

5. 上传完成后通知后端合并切片

## Express 和 koa 有什么关系，有什么区别？

Express.js 是一个灵活而简约的 Node.js 应用框架。这个插件并不是围绕着特定的组件构建的，因此它并不限制你使用什么技术。这就给了开发者尝试的自由。他们还可以获得闪电般的配置和纯 JavaScript 体验，这些特性使 Express.js 成为快速原型设计和敏捷开发市场的有力竞争者。

**Express.js 可以被用于：**

- 单页应用
- 多页应用
- 混合应用

**Express.js 主要特性：**

- 更快的服务端开发
- 赋能开发者更快地构建 RESTful API
- Express 支持 MVC 架构，但需要开发者做一些额外工作
- 开箱支持 NoSQL 数据库

**什么时候使用 Express.js：**

Express.js 是快速创建 Web 应用程序和服务的理想选择，因为它有现成的 API 生成工具。它是基于 JavaScript 的全栈方案 MEAN 的一部分。这意味着你可以使用 Express.js 来制作任何基于浏览器的企业级应用。

Koa.js 是一个开源的 Node web 框架，由 Express.js 原班人马创建。通过 Koa，他们的目标是为 Web 应用和 API 创建一个更小、更有价值、更强大的平台。它提供了多种高效的方法，以让构建服务的过程更快速。

**Koa.js 可以被用于：**

- 前台系统
- 后台系统
- 混合系统

**Koa.js 主要特性：**

- 代表现代和未来
- 与所有 Node.js 框架相比，体积更小。
- 有一个内置的错误捕捉器，防止网站崩溃。
- 使用 context 对象，该对象同时拥有请求和响应对象。

**什么时候使用 Koa.js：**

Koa.js 最适合用于创建服务器、路由、处理响应和处理错误。

# 单页面应用有什么 SEO 方案？

#### 服务端渲染重构

[Nuxt](https://link.juejin.cn/?target=https%3A%2F%2Fzh.nuxtjs.org%2F), [Next](https://link.juejin.cn/?target=https%3A%2F%2Fnextjs.org%2F).

#### 预渲染

原理: **启动一个无头浏览器, 加载应用程序的路由, 将结果保存到静态 HTML 文件中**

适合:

- **内容不会发生变化的页面**: 例如营销页面以及广告页面

不适合:

- **内容会变化的页面**: 像博客这种- -是不行的, 因为内容在编译后就确定了, 再修改内容, 也不会有变化

优点:

- **代码侵入少**: 安装一个 plugin, 指定路由即可

缺点:

- **覆盖范围少**: 几乎只适合静态页面

- **路由(页面)较多时构建时间长**

- **不科学上网 phantomjs 下不下来**: 当时踩的坑, 转头就捣鼓梯子去了

# 测试环境问题排查的那些事儿

**排查实践**

**案例一** **问题：**测试环境一个查询商品列表的接口，响应非常慢，经常超时。

**总结：**这个案例充分展示了合理使用工具的重要性。通过服务管理平台，能够快速确认服务是正常的，问题在于部分接口；通过 zzapm 强大的调用链追踪能力，能准确定位到耗时的节点，确定问题原因。

**案例二 问题：某 RPC 服务，部署后启动失败。**

**排查过程：**

- Step 1：查看服务进程，发现进程不存在；查看服务日志，发现没有生成日志；
- Step 2：查看 Java 虚拟机日志，发现在日志中间有一条异常输出，表明服务的端口被占用了；

**总结：**端口冲突的问题，曾经在测试环境频繁出现，给我们制造了很多麻烦。通过在排查过程中不断分析和总结，我们确定了问题的根本原因在于端口使用的不规范。进而制定并推广了服务端口的分配规范，只允许使用指定范围内的监听端口，并在测试环境中对这些端口进行了预留，从而彻底解决了这一问题。

# 什么是 CDN

CDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度。 CDN 其实是通过优化物理链路层传输过程中的网速有限、丢包等问题来提升网速的。

# 深度复制对象

总结一下——structuredClone()不会复制对象的原型链： 「死全捆能」

- 内置对象的副本具有与原始对象相同的原型。

- 自定义类的实例副本始终具有原型 Object.prototype（如普通对象）。

# React 的设计思想

- ##### 组件化 数据驱动视图 虚拟 DOM

# React18 有哪些更新？

react18，将所有事件都进行批处理，即多次 setState 会被合并为 1 次执行，提高了性能，在数据层，将多个状态更新合并成一次处理（在视图层，将多次渲染合并成一次渲染）

- concurrent Mode :渲染模型的变化 「肯可伦特」
- Automatic Batching :自动批量更新 state 变化，减少渲染次数 「
- Transition : 指定渲染优先级
- Suspense ：更加方便组织并行请求和 loading 状态的代码

1. 引入了新的 root API，支持 new concurrent renderer(并发模式的渲染)

2. setState 自动批处理 <!--react18，将所有事件都进行批处理，即多次setState会被合并为1次执行，提高了性能，在数据层，将多个状态更新合并成一次处理（在视图层，将多次渲染合并成一次渲染）-->

3. react 组件返回值更新 在 react17 中，返回空组件只能返回 null，显式返回 undefined 会报错 在 react18 中，支持 null 和 undefined 返回

   # JSX 与 JS 的区别？

   JS 可以被打包工具直接编译，不需要额外转换，jsx 需要通过 babel 编译，它是 React.createElement 的语法糖，使用 jsx 等价于 React.createElement

   1. jsx 是 js 的语法扩展，允许在 html 中写 JS； JS 是原生写法，需要通过 script 标签引入

   **为什么在文件中没有使用 react，也要在文件顶部 import React from “react”**

   只要使用了 jsx，就需要引用 react，因为 jsx 本质就是 React.createElement

   **React 组件为什么不能返回多个元素**

   1. React 组件最后会编译为 render 函数，函数的返回值只能是 1 个，如果不用单独的根节点包裹，就会并列返回多个值，这在 js 中是不允许的
   2. react 的虚拟 DOM 是一个树状结构，树的根节点只能是 1 个，如果有多个根节点，无法确认是在哪棵树上进行更新

# 简述 React 的生命周期

**constructor** 可以进行 state 和 props 的初始化

**componentDidMount** 第一次渲染后调用，可以访问 DOM，进行异步请求和定时器、消息订阅

**shouldComponentUpdate** 返回一个布尔值，默认返回 true，可以通过这个生命周期钩子进行性能优化，确认不需要更新组件时调用

**componentDidUpdate** 在组件完成更新后调用

**componentWillUnmount** 组件从 DOM 中被移除的时候调用

# React 事件机制

**什么是合成事件**

**React 基于浏览器的事件机制实现了一套自身的事件机制，它符合 W3C 规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等**

**React 事件机制**总结如下：

事件绑定 事件触发

- **React 所有的事件绑定在 container 上**(react17 以后),而不是绑定在 DOM 元素上（作用：减少内存开销，所有的事件处理都在 container 上，其他节点没有绑定事件） container 「肯提呢」
- React 自身实现了一套冒泡机制，不能通过 return false 阻止冒泡
- React 通过**SytheticEvent**实现了**事件合成** 「谁提呢晒问」

# 前端通用路由解决方案

- hash 模式

> 改变 URL 以#分割的路径字符串，让页面感知路由变化的一种模式,通过*hashchange*事件触发

- history 模式

> 通过浏览器的 history api 实现,通过*popState*事件触发

# react 组件通信方式有哪些

**父组件向子组件通信**

- **props 传递** 利用 React 单向数据流的思想，通过 props 传递

**子组件向父组件通信**

- **回调函数** 父组件向子组件传递一个函数，通过函数回调，拿到子组件传过来的值

**兄弟组件通信**

- 实际上就是通过父组件中转数据的，子组件 a 传递给父组件，父组件再传递给子组件 b

# Redux 工作原理

Redux 是一个状态管理库，使用场景：

- 跨层级组件数据共享与通信
- 一些需要持久化的全局数据，比如用户登录信息

Store 一个全局状态管理对象

Reducer 一个纯函数，根据旧 state 和 props 更新新 state

Action 改变状态的唯一方式是 dispatch action

# react fiber

1.为了使 react 渲染的过程中可以被中断，可以将控制权交还给浏览器，可以让位给高优先级的任务，浏览器空闲后在恢复渲染。

2.对于计算量比较大的 js 计算或者 dom 计算，就不会显得特别卡顿，而是是一帧一帧的有规律的执行任务

<!--generator 有类似的功能，为什么不直接使用-->

<!--要使用 generator ，需要将涉及到所有的代码都包装成generator*的形式，非常麻烦，工作量很大-->

**什么是 fiber，fiber 解决了什么问题**

在 React16 以前，React 更新是通过**树的深度优先遍历**完成的，遍历是不能中断的，当树的层级深就会产生栈的层级过深，页面渲染速度变慢的问题，为了解决这个问题引入了 fiber，React fiber 就是虚拟 DOM，它是一个链表结构，返回了 return、children、siblings，分别代表父 fiber，子 fiber 和兄弟 fiber，随时可中断

**Fiber 是纤程，比线程更精细，表示对渲染线程实现更精细的控制**

# 如何判断当前是否有高优任务呢？

1.当前 ji 环境其实是没有办法判断是否有高优任务，只能约定一个合理的执行时间，当超过这个执行时间，如果任务仍然没有执行完，中断当前任务，将控制权交给浏览器

2 .requestIdleCallback 回调函数 （浏览器 API） 浏览器在有空时候执行我们的回调，这个回调有一个参数，表示浏览器有多少时间供我们执行任务。

#### react 预定 5 个优先级的登记

- Immediate 最高优先级，这个优先级的任务应该马上被执行不能中断。 「迷笛」
- UserBlocking 这些任务一般是用户交互的结果，需要及时得到反馈。 「忧思布拉 king」
- Normal 不需用户立即就感受到的变化，比如网络请求。 「弄膜」
- low 这些任务可以延后，但最终也需要执行
- Idle 可以被无限期延后

# 谈谈你对高阶组件 HOC 的看法？

1.简称 HOC ，是一个函数

2.入参：原来的 react 组件

3.返回值：新的 react 组件

4.是一个纯函数，不应该有任何的副作用。

答：**不是一个组件，而是一个用来包装组件的函数(高阶函数/纯函数)，并且必须返回一个新的函数**

纯函数

1. 不修改传入的参数
2. 固定输入有固定输出

定义高阶组件（1.把组件作为参数传入 2.返回一个新的组件）

-

##### 普通方式、装饰器，多个高阶组件的组合

**作用：**1. 属性代理 操作 props 、操作组件实例 2.继承、属性劫持

# 什么是 react hooks？React hooks 有什么优势？

useState、useEffect、useMemo、useCallback

Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。

## React 组件更新逻辑

- 在使用 Hook 前先要了解，React 组件在什么情况下会刷新

  1. state 或 props 有更新时，当前组件会刷新
  2. 父组件有更新时，当前组件会刷新

- 但，从上面的情况看，其中有两个问题：
  1. 调用`setState()`，就会触发组件的重新渲染（无论前后的 state 是否一样，除非继承自`PureComponent`）
  2. 父组件更新，子组件也会自动的更新（无论子组件是否有必要更新）

Hook 除了能让函数组件使用一些类组特性外，还自带一些性能优化，使函数组件发挥出强大的优势

### class 「类组件的」 的缺点：

1. 组件间的状态逻辑很难复用 <!--组件间如果有state的逻辑是相似，class 模式下基本都是高级组件来解决，但是我们需要在组件外部在包一层元素，会导致层级非常沉余-->
2. 复杂业务的有状态组件会越来越复杂
3. 监听和定时器的操作，被分割在多个区域 <!--「养成好的习惯，清除定时器，不然会内存泄露」-->

render 里 bind 每次都会返回一个新的函数，造成每次都重新渲染 <!--每次都是新的引用，箭头函数是在定义的时候确定了this指向，而不是使用的时候-->

1. 类组件需要声明 constructor，函数组件不需要
2. 类组件需要手动绑定 this，函数组件不需要
3. 类组件有生命周期钩子，函数组件没有
4. 类组件可以定义并维护自己的 state，属于有状态组件，函数组件是无状态组件
5. 类组件需要继承 class，函数组件不需要

### Hooks 的优点：

1. 利于业务逻辑的封装和拆分，可以非常自由的组合各种自定义 hooks（自己封装的用到了 react hooks 的公共逻辑）
2. 可以在无需修改组件结构的情况下，复用状态逻辑
3. 定时器 监听等等都被聚合到同一块代码下

# SetState 是同步还是异步呢？

setState 是一个异步方法，但是在 setTimeout/setInterval 等定时器里逃脱了 React 对它的掌控，变成了同步方法

## Hook 使用注意事项

1. 只能在函数内部的最外层调用 hook ，不要在循环，条件或嵌套函数中调用 。

2. 只能在 React 的函数组件中调用 Hook，不要在其他的 js 函数里调用 <!--「数据来源是根据下标来获取，多个时候会错位」-->

## 基础 Hook

### 1. useState

State Hook 能让函数组件也能使用 class 组件一样的状态特性，同时发挥函数组件轻便高效的特性，格式：`useState(defaultValue)`，返回最新**value**与**修改 value**方法组成的数组

### 2. useEffect

Effect Hook 可以让我们在函数组件中执行一些副作用操作，如 ajax 请求，定时器等。默认情况下，effect 将在每轮**渲染结束后执行**，React 保证了每次运行 effect 时，DOM 都已经更新完毕

- 默认 effect

  > 等效于 componentDidMount + componentDidUpdate 的效果 PS：ajax 请求以前在 class 组件中可能需要在`componentDidMount`和`componentDidUpdate`两个生命周期函数中编写相同的代码，有了`useEffect`，只需要写一次就行

- 指定依赖

  > 等效于 componentDidUpdate 的效果，只有在依赖发生改变时才执行 effect 中的代码

* 指定空依赖

  > 依赖为空数组，等效于 componentDidMount 的效果

* useEffect 返回一个函数

  > 实现 componentWillUnmount 的效果

### 3. useMemo

> 一般用于编写函数组件中无需重复执行的代码，以达到**优化性能**的目的，返回值为回调函数的结果

- 执行过程
  1. 回调函数初始化组件时会被执行
  2. 依赖改变时被执行
- 返回值：依赖改变返回新的值，否则返回缓存值

### 4. useCallback

> 与 useMemo 类似，但 useCallback **返回传入的函数**，不需要显性返回，一般用于定义事件处理函数

- 不指定依赖

  > 不论初始化或者组件更新都返回新的函数

* 指定依赖

  > 依赖更新时返回新的函数，否则返回缓存函数

* 空依赖

  > 初始化返回函数后并缓存，组件更新时永远返回缓存函数

## 额外的 Hook

1. useContext

> `useContext(MyContext)` 相当于 class 组件中的 `static contextType = MyContext` 或者 `<MyContext.Consumer>`，当组件上层最近的 `<MyContext.Provider>` 更新时，该 Hook 会触发重渲染

2. useReducer

> 简单版 redux，可以在不引入 redux 的情况下使用 redux 特性

> PS: 如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行

3. useRef
   `useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数，返回的 ref 对象在组件的整个生命周期内保持不变。

4. useLayoutEffect
5. useImperativeHandle
6. useDebugValue

# 埋点方案

#### 3.1.1 代码埋点

- 嵌入代码的形式
- 优点：精确（任意时刻，数据量全面）
- 缺点：代码工作量点

#### 3.1.2 可视化埋点

- 通过可视化交互的手段，代替代码埋点
- 将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码
- 用系统来代替手工插入埋点代码

#### 3.1.3 无痕埋点

- 前端的任意一个事件被绑定一个标识，所有的事件都被记录下来
- 通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析
- 无痕埋点的优点是采集全量数据，不会出现漏埋和误埋等现象
- 缺点是给数据传输和服务器增加压力，也无法灵活定制数据结构

### 业务 business

- pv：页面浏览量和点击量
- uv：用户访问量、UV 同一天内多次访问只算一次，UV 的统计放在服务端来做
- 用户在每一个页面的停留时间

### 用户行为数据：

- 页面浏览量或点击量、用户在每一个页面的停留时间、用户通过什么入口来访问该页面、用户在相应的页面中触发的行为。用户行为数据可以通过一些 DOM 元素的操作事件来获取。

1:监控埋点： 明确埋点，或者说我们要获取的数据是什么。JS 的报错，图文的报错，相关的一些资源的报错，

个接入方式，接入方式的话，第一种接入的话是有埋的一个接入方式，

无埋点：引路 sdk 会默认监听，或者说我们默认的话，会重写我们底层的一个圆圆形的方法，通过监听我们圆形方法上的视线的话，来监听我们的时间，来听听我们的一个异常，

一定要进行上报，削峰减流

上报的一个方式是使用那个方式：接口、图片

# 性能监控指标

### 根据相对应的指标

- 比如⻚页⾯面性能检测利用工具，结合相对的指标逐个优化。

- 只请求当前需要的资源，异步加载, 懒加载, polyfill 的优化，<!--「利用 polyfill 插件 cdn 按需引入，减小包的大小」-->

- 缩减资源体积

  1.打包压缩 2.gzip 开启 3.图⽚片格式优化, 压缩, 根据屏幕分辨率展示不不同分辨率的图⽚片 4.尽量量控制 cookie 大⼩

- 时序优化

  js 中 promise.all 、ssr 、 prefetch、prerender、preload <!--「嵌入link 标签 <link rel="dns-prefetch" href="xxxxxx" />」-->

- 合理理利利⽤用缓存

  cdn、http 缓存、localStorage, sessionStorage

  #### 导致内存泄漏的方法，怎么监控内存泄漏

  - 全局变量

  - 被遗忘的定时器 <!--未被清理理的定时器器和回调函数-->

  - 脱离 Dom 的引用 <!--我们对 Dom 的操作, 会把 Dom 的引⽤用保存在⼀一个数组或者 Map 中-->

  - 闭包 <!--一个内部函数，有权访问包含其的外部函数中的变量。-->

    ##### 监控内存泄漏

  - window.performance.memory

  - 开发阶段

    - 浏览器的 Performance
    - 移动端可使用 PerformanceDog

  #### 内存的⽣生命周期

  内存分配:当我们申明变量量、函数、对象的时候，系统会⾃自动为他们分配内存

  内存使用:即读写内存，也就是使⽤用变量量、函数等

  内存回收:使⽤用完毕，由垃圾回收机制⾃自动回收不不再使⽤用的内存

  #### Js 中的垃圾回收机制

  垃圾回收算法主要依赖于引⽤用的概念。

  在内存管理理的环境中，一个对象如果有访问另一个对象的权限(隐式或者显式)，叫做一个对象引用另一个对象。

  - 例如，一个 Javascript 对象具有对它原型的引⽤用(隐式引⽤用)和对它属性的引⽤用(显式引用)。 <!--在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域(或者全局词法作用域)。-->

  1 、引⽤用计数垃圾回收 2 、标记清除算法

  # 如果⼀段 js 执行时间非常长,怎么去分析?

  ## 缓存策略

  缓存策略可以分为**强缓存**和**协商缓存**，这两种缓存策略都是通过设置 HTTP Header 来实现的

  ### 强缓存

  - 强缓存可以通过设置两种 HTTP Header 来实现： **Expires** 和 **Cache-Control** 。 =一死派儿死 全死肯求
  - 强缓存表示在缓存期间是不需要重新请求的， state code 为 200。
  - Exprires 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires 是 HTTP1.0 的产物，故现在大多数使用 Cache-Control 替代。

  Cache-Control 有很多属性，不同的属性代表的意义也不同。

  - private：客户端可以缓存 「派位特」

  - public：客户端和代理服务器都可以缓存。「跑不累可」

  - max-age=t：缓存内容将在 t 秒后失效

  - no-cache：需要使用协商缓存来验证缓存数据 「no 卡去」

  - no-store：所有内容都不会缓存。 「no 死到」

  # 刷新对于强缓存和协商缓存的影响

  \1. 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。

  \2. 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存。

  \3. 浏览器地址栏中写入 URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）

  ### 协商缓存

  协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回 304 状态码，浏览器拿到此状态码就可以直接使用缓存数据了。

  这时通过设置两种 HTTP Header 实现：**Last - Modified**  和  **Etag**。

  Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。 「拉斯莫提 fied」

  Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

  #### 57.cookie,localStorage 和 sessionStorage 的区别

  Cookie:一般由服务器生成，可设置失效时间。如果在浏览器端生成 Cookie，如果使用 cookie 保存过多数据会带来性能问题.localstorage:除非被清除，否则永久保存。仅在客户端（即浏览器）中保存，不参与和服务器的通信 sessionStorage：仅在当前会话下有效，关闭页面或浏览器后被清除。仅在客户端（即浏览器）中保存，不参与和服务器的通信

  # 如何判定一个元素是否处于事件冒泡阶段？

  答：利用 e.currentTarget 和 e.target 判断是否为同一元素，如果是同一元素就是在冒泡，e.currentTarget 指的是被绑定了事件的元素，也就是事件源，e.target 则是点击到的事件源下面的某个元素,也就是触发事件元素

  # 模块化开发的区别？

  答：1.commonjs -->同步
  2.amd&cmd -->异步
  3.EsModule -->静态引入，不能使用变量，其他模块可以

  # ES Module 和 CommonJS 的区别

  CommonJS 输出的是值的拷贝，ES Module 输出的是值的引用

  CommonJS 是运行时加载（module.exports），ES Module 是编译时输出接口

  CommonJS 的 require（）是同步加载模块，ESModule 的 import 是异步加载模块，静态编译时加载，有独立的模块依赖解析

  CommonJS 模块的顶层 this 指向当前模块，ES6 模块中，顶层 this 指向 undefined

  ES Module：静态加载/编译时加载

  CommonJS：运行加载

  ESM 效率要比 CommonJS 模块的加载方式高，动态绑定关系

  import：静态执行，会提升，不可修改/只读

  export default：指定模块的输出，输出一个叫做 default 的方法/变量，系统允许修改名称

  import（）：动态加载模块，当需要按需加载时使用

  #

  # Typescript

  ### Class 类

  面向对象编程的三大特点

  - **封装（Encapsulation）**：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，
  - **继承（Inheritance）**：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性。
  - **多态（Polymorphism）**：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。

  [类成员的访问修饰符](https://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers)

  - **public** 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的
  - **private** 修饰的属性或方法是私有的，不能在声明它的类的外部访问
  - **protected** 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的

  ### 泛型 Generics

  泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。

  ### implements 与 extends 的区别

  extends 子类会继承父类的所有属性和方法
  implements 使用该关键字的类将需要实现的需要实现的类的所有属性和方法。

  ### keyof 和 typeof 关键字的作用

  keyof 索引类型查询操作符 获取索引类型的属性名，构成联合类型。
  typeof 获取一个变量或对象的类型

  ### interface 和 type 区别

  interface：接口主要用于类型检查，它只是一个结构契约，定义了具有相似的名称和类型的对象结构。除此之外，接口还可以定义方法和事件,声明两个相同接口会合并，interface extends type

  type：不同于 interface 只能定义对象类型，type 声明还可以定义基础类型、联合类型或交叉类型。type 可以使用 typeof 获取实例类型 type x = typeof div type y = string & interface yy{x:1}|

  两者最关键的差别在于类型别名本身无法添加新的属性，而接口是可以扩展的

  类型别名 通过交集(&)扩展类型

  ### Exclude、Omit、Merge、Intersection、Overwrite 的作用

  Exclude<T, U>此工具是在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分。

  Omit<T, K>此工具可认为是适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对。

  Merge<O1, O2>将两个对象的属性合并.

  Compute<A & B>将交叉类型合并.

  Intersection<T, U>取 T 的属性，此属性同样哦存在于 U.

  Overwrite<T, U>用 U 的属性覆盖 T 的相同属性.

  Pick<T, K>此工具的作用是将 T 类型中的 K 键列表提取出来，生成新的子键值对类型。

  Partial<T>将属性全部变为可选属性

  Record<K, T> 把属性全部变为必须属性

  Extract<T, U> 获取类型交集 type Key = 'a' | 'b' | 'c'; type A = Extract<Key, 'a'>; // 'a'

# git merge 和 git rebase 的区别？

相同点：

`git merge`和`git rebase`两个命令都⽤于从⼀个分⽀获取内容并合并到当前分⽀。

不同点：

1. `git merge`会⾃动创建⼀个新的`commit`，如果合并时遇到冲突的话，只需要修改后重新`commit`。

- 优点：能记录真实的`commit`情况，包括每个分⽀的详情
- 缺点：由于每次`merge`会⾃动产⽣⼀个`commit`，因此在使用⼀些可视化的 git 工具时会看到这些自动产生的`commit`，这些`commit`对于程序员来说没有什么特别的意义，多了反而会影响阅读。

1. `git rebase`会合并之前的`commit`历史。

- 优点：可以得到更简洁的提交历史，去掉了 merge 产生的`commit`
- 缺点：因为合并而产生的代码问题，就不容易定位，因为会重写提交历史信息

场景：

- 当需要保留详细的合并信息，建议使⽤`git merge`, 尤其是要合并到`master`上
- 当发现⾃⼰修改某个功能时提交比较频繁，并觉得过多的合并记录信息对自己来说没有必要，那么可尝试使用`git rebase`

# 对 GitFlow 的理解？

GitFlow 重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。重点是对各个分支的理解。

- `master`：主分支。
- `develop`：主开发分支，平行于`master`分支。
- `feature`：功能分支，必须从`develop`分支建立，开发完成后合并到`develop`分支。
- `release`：发布分支，发布的时候用，一般测试时候发现的 bug 在该分支进行修复。从`develop`分支建立，完成后合并回`develop`与`master`分支。
- `hotfix`：紧急修复线上 bug 使用，必须从`master`分支建立，完成后合并回`develop`与`master`分支。

---
