## MVC/MVVM 的区别,说下 MVVM

- M：Model（服务器上的业务逻辑操作）
- V：View（页面）
- VM：ViewModel（Model 与 View 之间核心枢纽，比如 Vue.js）

## mvc 和 mvvm 各自的优点

**MVC 的优缺点**

优点：

- 耦合性低，视图模型控制器三者相互分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码。
- 重用性高，多个视图能共享一个模型
- 可维护性高，分离视图层和业务逻辑层也使得 WEB 应用更易于维护和修改。
- 前后端可以分工作业，提升开发效率

缺点：

- 不适合小型应用程序

- 增加系统结构和实现的复杂性

- 控制层和表现层有时会过于紧密，导致没有真正分离和重用

  **MVVM 的优缺点**

  优点

​ 1.双向绑定技术，当 Model 变化时，View-Model 会自动更新，View 也会自动变化,能很好的做到数据一致性。

​ 2.View 的功能进一步的强化，具有控制的部分功能。

​ 3.UI 和逻辑的开发解耦。

缺点：

1.数据绑定使得 Bug 不易调试，也会使得一个位置的 Bug 被快速传递到别的位置。

2.虽然使用 Model 方便了保证数据一致性，但是大的模块中长期不释放内存就会造成花费更多的内存。

3.数据双向绑定不利于 View 部分的代码复用。

## display 用法 inline-block 和 block

display:block 特点

1、独占一行，多个 block 元素另起一行，默认情况下，block 元素宽度自动填满其父元素宽度

2、block 元素可以设置 width,height 属性。块元素即使设置了宽度,仍然是独占一行。

3、block 元素可以设置 margin 和 padding 属性。

display:inline-block 特点

简单的说，就是将对象呈现为 inline 对象，让 block 元素不再独占一行，多个 block 元素可以同排一行，且元素具有 block 的属性，可设置宽高，是 block 和 inline 元素的综合体。

## TCP 跟 UDP 的区别

1、TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不需要建立连接

2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付

3、TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流;UDP 是面向报文的

4、每一条 TCP 连接只能是点到点的;UDP 支持一对一，一对多，多对一和多对多的交互通信

## 将伪数组转为真正的数组

> Array.prototype.slice.call() <br/>
> Array.from()

## 数据类型中 5 个数据转化为 false

0、'' 、null、undefine、NaN

## JS 中检测数据类型的四种方法

#### typeof

typeof 可以用于检测基本类型，但碰到引用类型均返回为 object。

#### instanceof

instanceof 可以用于引用类型的检测，但对于基本类型是不生效的，另外，不能用于检测 null 和 undefined。

#### constructor

constructor 能用于检测 js 的基本类型和引用类型。

#### Object.prototype.toString.call()

Object.prototype.toString.call()可用于检测 js 所有的数据类型。

## less 和 sass 区别

Less 是基于 JavaScript，是在客户端进行处理的；Sass 是基于 Ruby，是在服务器端进行处理的。

**定义变量：**Less 定义变量时使用前缀：@；Sass 定义变量时使用前缀：$。

## 单页面应用有什么 SEO 方案？

> 服务端渲染重构:[Nuxt](https://link.juejin.cn/?target=https%3A%2F%2Fzh.nuxtjs.org%2F), [Next](https://link.juejin.cn/?target=https%3A%2F%2Fnextjs.org%2F).

## 预渲染

原理: **启动一个无头浏览器, 加载应用程序的路由, 将结果保存到静态 HTML 文件中**

适合:

- **内容不会发生变化的页面**: 例如营销页面以及广告页面

不适合:

- **内容会变化的页面**: 像博客这种- -是不行的, 因为内容在编译后就确定了, 再修改内容, 也不会有变化

优点:

- **代码侵入少**: 安装一个 plugin, 指定路由即可

缺点:

- **覆盖范围少**: 几乎只适合静态页面

- **路由(页面)较多时构建时间长**

- **不科学上网 phantomjs 下不下来**: 当时踩的坑, 转头就捣鼓梯子去了

## JS 执行机制

由于 JS 是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。

为了避免因为某些长时间任务造成的无意义等待，JS 引入了异步的概念，用另一个线程来管理异步任务。

同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如 ajax 请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。

## 什么是 CDN

CDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度。 CDN 其实是通过优化物理链路层传输过程中的网速有限、丢包等问题来提升网速的。

## 深度复制对象

总结一下——structuredClone()不会复制对象的原型链： 「死全捆能」

- 内置对象的副本具有与原始对象相同的原型。

- 自定义类的实例副本始终具有原型 Object.prototype（如普通对象）。

## 如果⼀段 js 执行时间非常长,怎么去分析?

## 如何判定一个元素是否处于事件冒泡阶段？

答：利用 e.currentTarget 和 e.target 判断是否为同一元素，如果是同一元素就是在冒泡，e.currentTarget 指的是被绑定了事件的元素，也就是事件源，e.target 则是点击到的事件源下面的某个元素,也就是触发事件元素

## 模块化开发的区别？

答：1.commonjs -->同步
2.amd&cmd -->异步
3.EsModule -->静态引入，不能使用变量，其他模块可以

## ES Module 和 CommonJS 的区别

CommonJS 输出的是值的拷贝，ES Module 输出的是值的引用

CommonJS 是运行时加载（module.exports），ES Module 是编译时输出接口

CommonJS 的 require（）是同步加载模块，ESModule 的 import 是异步加载模块，静态编译时加载，有独立的模块依赖解析

CommonJS 模块的顶层 this 指向当前模块，ES6 模块中，顶层 this 指向 undefined

ES Module：静态加载/编译时加载

CommonJS：运行加载

ESM 效率要比 CommonJS 模块的加载方式高，动态绑定关系

import：静态执行，会提升，不可修改/只读

export default：指定模块的输出，输出一个叫做 default 的方法/变量，系统允许修改名称

import（）：动态加载模块，当需要按需加载时使用

## 什么是同源策略

只有当协议，域名，端口都一致的时候，才被称为同源

## 解决跨域常见的 5 种方法

- JSONP （JSONP 只支持 GET 请求，不支持 POST 请求 ）

- 反向代理（写一个接口 ，由这个接口在后端去调用 ，并拿到返回值，然后再返回给 index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。 ）

- CORS 方法 （设置响应头，在 header 中添加

  header('Access-Control-Allow-Origin:\*');//允许所有来源访问

  header('Access-Control-Allow-Method:POST,GET');//允许访问的方式）

- webpack 代理需要另外一个插件：webpack-dev-server。 只需要条件一个 proxy 属性

- nginx 代理一般使用在生产环境。是服务端解决跨域的一种方案。
  > [!TIP]
  > 修改 nginx.conf 文件，加上跨域头，代理调试地址，接口地址。 修改 nginx server 配置 _#允许请求的 header_ _#允许带上 cookie 请求_ _#允许请求的方法，比如 GET,POST,PUT,DELETE_

## 什么是闭包？

- 闭包就是能够读取其他函数内部变量的函数。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。缺点是会造成内存溢出，变量无法被销毁

**闭包作用**

- 隐藏变量，避免全局污染

- 可以读取函数内部的变量

同时闭包使用不当，优点就变成了缺点:

优点 1:导致变量不会被垃圾回收机制回收，造成内存消耗

缺点 2:不恰当的使用闭包可能会造成内存泄漏的问题

这里简单说一下，为什么使用闭包时变量不会被垃圾回收机制收销毁呢，这里需要了解一下 JS 垃圾回收机制;

JS 规定在一个承数作用域内，程序执行完以后变量就会被销毁，这样可节省内存:

使用闭包时，按照作用域链的特点，闭包(函数)外面的变量不会被销毁，因为函数会一直被调用，所以一直存在，如果闭包使用过多会造成内存销毁。

## 深拷贝和浅拷贝的区别？

答：**深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。**

假设 B 复制了 A，修改 A 的时候，看 B 是否发生变化：

如果 B 跟着**也变了**，说明是**浅拷贝**，拿人手短！（修改堆内存中的同一个值）

如果 B**没有改变**，说明是深拷贝，自食其力！（修改堆内存中的不同的值）

所以：**浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，**

以及：**深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存**

## 那如何对一个对象进行深拷贝呢？

答：**方法一：分别对数组、对象、基本数据类型值进行判断、考虑，使用递归的方式复制值**

**方法二：利用 JSON.parse()、JSON.stringify()这两个方法实现深拷贝**

## Js 中的垃圾回收机制

垃圾回收算法主要依赖于引⽤用的概念。

在内存管理理的环境中，一个对象如果有访问另一个对象的权限(隐式或者显式)，叫做一个对象引用另一个对象。

- 例如，一个 Javascript 对象具有对它原型的引⽤用(隐式引⽤用)和对它属性的引⽤用(显式引用)。 <!--在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域(或者全局词法作用域)。-->

1 、引⽤用计数垃圾回收 2 、标记清除算法

## 普通函数和箭头函数的区别？

1.箭头函数是匿名函数，不能作为构造函数，不能使用 new

2.箭头函数不绑定 arguments，取而代之用 rest 参数...解决

3.箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。箭头函数内的 this 指向上层对象，bind()、call()、apply()均无法改变指向

4.箭头函数没有原型属性

5.箭头函数不能当做 Generator 函数,不能使用 yield 关键字

（yield 关键字很像 return，所不同的是，它返回的是一个生成器。 ）

6.两种函数的 this 代表不一样：f1 是箭头函数，this 代表上层对象，若无自定义上层，则代表 window。普通函数，this 代表当前对象。

## call,bind 和 apply 的异同

- 相同点三个函数都会改变 this 的指向（调用这三个函数的函数内部的 this）。都是函数的原型方法

  **不同点：**

- call 和 apply 都会调用函数，不会产生新的函数，只是在调用时，绑定一下而已。bind 不会调用函数，会产生新的函数
- call 和 bind 传参一致，和 apply 的区别，第一个参数都是要绑定的 this，apply 第二个参数是数组（是函数的所有参数），call 把 apply 的第二个参数单列出来。
- bind 只会执行一次，而且只认第一次改变的 This 指向

## 原型链继承的优缺点?

答：原型链实现继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

1.缺点就是让结果所有的子类的实例都会共享父类的实例属性

2.通过原型链继承的方式，原先存在父类型的实例中的所有属性和方法，现在也能存在于子类型的原型中了。

## 谈谈对原型与原型链的理解?

原型链（对象查找属性的一个机制）实例到 Object.prototype 间的一个链条，

就近原则查找---》在自己的作用域找，有就使用，没有就继续往上层查找，直到找到全局为止，还找不到就会报错 1.在本身的对象上查找一个属性，如果有就直接使用，没有就去所属的构造函数上的原型对象查找

2.在构造函数的原型上，找到就使用，找不到就继续去构造函数的原型对象的原型对象上查找

3.直到找到 object 的原型对象上，如果找到就使用，找不到就报错了

属性访问规则（在原型链中逐层往上查找，找不到返回 underfind）

属性访问规则（在原型链中逐层往上查找，找不到返回报错）

三者的关系（构造函数，原型链，原型对象）

1. 每个构造函数都有一个原型对象（prototype）
2. 原型对象都包含一个指针指向构造函数（constructor）
3. 所以的实例都通过\_ _proto_ \_ \_指向同一个原型对象（包含一个指向原型对象的内部指针（[[prototype]]）

构造函数 new 出来一个对象，而每个对象都有一个 constructor 属性，该属性指向创建该实例的构造函数，构造函数的 prototype 属性是这个 new 出来的实例化对象的原型，实例对象通过\_**_proto_**或者 object.getPrototype 的方法获取原型。

## 那什么是递归呢？

答：递归，就是在运行的过程中调用自己， **斐波纳契数列是典型的递归案例**

**构成递归所必须的条件？**

1.子问题须与原始问题为同样的事，且更为简单

2.不能无限制地调用本身，须有个出口，化简为非递归状况处理

## 谈谈 async/await 的使用方式和场景

答：async 是用来修饰函数的声明, 使用 async 修饰的函数会变成一个异步
函数.

await 用来修饰函数的调用, 被 await 修饰的函数必须返回一个
promise 异步对象, 使用 await 修饰后, 就会**将 promise 异步对象转换**
**成一个同步操作，**

一般配合**try**和**catch**使用

## 节流防抖的理解？

有些事件我们是无法控制触发频率的。 如鼠标移动事件 onmousemove, 滚动滚动条事件 onscroll，窗口大小改变事件 onresize，瞬间的操作都会导致这些事件会被高频触发。

**防抖：抖动。策略是当事件被触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作。 这是 debounce 的基本思想，在后期又扩展了前缘 debounce，即执行动作在前，然后设定周期，周期内有事件被触发，不执行动作，且周期重新设定**

> [!TIP]触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

**节流的策略是，固定周期内，只执行一次动作，若有新事件触发，不执行。周期结束后，又有事件触发，开始新的周期。 节流策略也分前缘和延迟两种。与 debounce 类似，延迟是指 周期结束后执行动作，前缘是指执行动作后再开始周期。**

## websocket 的 http 的特性，和传统的 http 有什么不同

都建立在 TCP，通过 TCP 协议传输数据；都是应用层协议

HTTP 单向传输，浏览器只有向服务器请求资源后，服务器才能传数据；

服务器不再是被动的接到客户端的请求后才返回数据，而是有了新数据后主动推送给客户端。

## 设置模式

定义:**观察者模**式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。

​ **单例模式：**保证一个类仅有一个实例,并提供一个访问它全局的点

## 单个网页 tab 是单个进程还是线程？

- 进程是 CPU 资源分配的最小单位

- 线程是 CPU 调度的最小单位

## 参与到网页生成流程中，有哪些线程？

GUI 渲染线程 / JS 引擎线程 /定时器触发线程 ，异步 HTTP 请求线程 /事件触发线程

## JS 分为同步任务和异步任务

=＞同步异步区分

2．同步任务都在主线程上执行，形成一个执行栈(JS 引擎线程）

3．主线程之外，事件触发线程维护任务队列，异步任务有了回调，就在队列中插入一个事件 二＞任务队列的调度
方式<br/> 4.
一旦执行栈中所有同步执行完成，系统就会读取任务队列，并且把可运行的异步任务转移到可执行栈中

## event loop

**两种任务？**

宏任务：整体代码，setTimeout, setInterval， I/0 操作

微任务：new Promise().then, Mutaionobserver (前端的回湖）

**为什么要引入微任务的概念，只有宏任务可以吗？**
宏任务 先进先出的原则执行。

**Node 中的事件循环和浏览器中的事件循环有什么区别？**

宏任务的执行顺序：

1. timers 定时器：执行已经安排的 setTimeout 和 setInterval 的回调函数
2. pending cal1back 待定回调：执行延迟到下一个循环迭代的工/0 回调

3. idle, prepare：仅系统内部使用。

4. poll：检索新的工/0 事件，执行与 I/0 相关的回调

5. check：执行 setImmediate（）回调函数

6. close callbacks: socket.on( 'close', () => (3)

**微任务和宏任务在 node 的执行顺序：**

Node v10 及以前：

1，执行完一个阶段中的所有任务

2．执行 nextTick 队列里的内容 3.执行完微任务队列的内容

Node v10 以后：
和浏览器的行为统一了。1 工
You, seconds

## promise

**Promise.all**
可以把多个 Promise 实例打包成一个新的 Promise 实例。传进去一个值为多个
Promise 对象的数组，成功的时候返回一个结果的数组，返回值的顺序和传进去的顺序是一致对应得上的，如果失败的话就返回最先 reject 状态的值

如果遇到需要同时发送多个请求并且按顺序返回结果的话，Promiseall 就可以完美解决这个问题

```
MyPromise.all=function(promisesList){	js 复制代码
let arr = []
return new MyPromise((resolvereiect)=>{ if(!promisesList.length)resolve([])
//直接环同时执行传进来的promise
for (const promise of promisesList){ promise.then((res)=>{// 保存返回结果 arr.push(res)
if(arr.length===promisesListlength){
  //执行结束 返回结果集合 resolve(arr)}
},reject)
})
```

**Promise.race**

传参和上面的 all 一模一样，传入一个 Promise 实例集合的数组，然后全部同时执行，谁先快先执行完就返回谁，只返回一个结果

## ES6 新特性

- let,const
- 字符串模板
- 解构
- 箭头函数
- ...运算符
- 对象简写
- **Promise**
- **class**
- **ESModule**
- **Proxy**
- Set/Map(set 集合里面是一些有序的集合，用他做过数组去重)
- Generator（生成器）
- Iterator( 迭代器： 一个数据结构只要具有**Symbol.iterator**属性，就可以认为是“可遍历的”（iterable）
- Symbol（本质上是一种唯一标识符，可用作对象的唯一属性名 ）
- Symbol 不是对象，不能添加属性（是一种类似于字符串的数据类型

## 什么是虚拟 DOM，以及他的优点

答：虚拟 DOM 到底是什么，说简单点，就是一个普通的 JavaScript 对象，包含了?`tag`、`props`、`children`?三个属性。

虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后**只对变化的 DOM 进行操作**，而**不是更新整个视图**。

**缺点：**<br/> 1.首次渲染大量 dom 的时候，由于多了一层虚拟 dom 的计算，会比 innerHTML 的插入速度慢

​2.做一些针对性的优化的时候，真是 dom 的操作还是更快一点的
